### 类成员初始化方式，构造函数的执行顺序 为什么用成员初始化列表会快一些
1. 赋值初始化，通过在函数体内进行赋值初始化；列表初始化，在冒号后使用初始化列表进行初始化
两种方式的主要区别在于：
对于函数体中初始化，是在所有的数据成员被分配内存空间后才进行的。
列表初始化是给数据成员分配内存空间时就进行初始化，就是说分配一个数据成员只要冒号后有此数据的赋值
表达式(此表达式必须时括号赋值表达式)，那么分配了内存空间后进入函数体之前给数据成员赋值。
2. 一个派生类构造函数的执行顺序如下：
    1. 虚拟基类的构造函数(多个虚拟基类则按照继承的顺序执行构造函数)。
    2. 基类的构造函数(多个普通基类也按照继承的顺序执行构造函数)。
    3. 类类型的成员对象的构造函数(按照初始化顺序)。
    4. 派生类自己的构造函数。
3. 方法一是在构造函数中做赋值的操作，而方法而是做纯粹的初始化操作。C++的赋值操作是会产生临时对象的。

### 有哪些情况必须用到成员列表初始化？作用是什么
1. 必须使用成员列表初始化的四种情况：
   1. 当初始化一个引用成员时。
   2. 当初始化一个常量成员时。
   3. 当调用一个基类的构造函数，而它拥有参数时。
   4. 当调用一个成员类的构造函数，而它拥有参数时。
2. 成员初始化列表做了什么?
   1. 编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且任何显示用户代码之前。
   2. list中的项目顺序是由类中的成员顺序决定的，不是由初始化列表的顺序决定的。

### 移动构造函数
1. 用对象a初始化对象b，后对象a就不再使用了，但是对象a的空间还在(在析构之前)，既然拷贝构造函数，实际上就是把a对象的内容赋值一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
2. 拷贝构造函数中，对于指针，我们一定要采用深层赋值，而移动构造函数中，对于指针，我们采用浅层复制。浅层复制之所以危险，是因为两个指针共同指向一片内存空间，若第一个指针将其释放，另一个指针的指向就不合法了。所以只需要避免第一个指针释放空间就可以了。方法就是将第一个指针置为NULL。
3. 移动构造函数的参数与拷贝构造函数不同，拷贝构造函数的参数是一个左值引用，但是移动构造函数的初值是一个右值引用。意味着，移动构造函数的参数是一个右值或者将亡值的引用。也就是说，只有用一个右值，或者将亡值初始化另一个对象时，才会调用移动构造函数。move语句，就是将一个左值变成一个将亡值。

### 如何获得结构成员相对于结构开头的字节偏移量
使用offsetof宏
```cpp
   struct S {
      int x;
      char y;
      int z;
      double a;
   }

   cout << offsetof(S, x) << endl; // 0
   cout << offsetof(S, y) << endl; // 4
   cout << offsetof(S, z) << endl; // 8
   cout << offsetof(S, a) << endl; // 16 这里是 16的位置，因为 double是8字节，需要找一个8的倍数对齐，

```
### 静态类型和动态类型，静态绑定和动态绑定的介绍
- 静态类型：对象在声明时采用的类型，在编译器既已确定
- 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期决定的。
- 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译器。
- 动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期。
从上面的定义也可以看出，非虚函数一般都是静态绑定，而虚函数都是动态绑定。


