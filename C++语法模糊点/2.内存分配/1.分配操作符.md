## 区别
### new/delete malloc/free区别
1. new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。
2. 使用new操作符申请内存分配时无需指定内存块的大小。编译器会自动根据类型信息自行计算。malloc需要显示
指定所需内存的尺寸。
3. new分配成功时，返回的时类型对象的指针，类型严格与对象匹配，无需进行类型转换。new是符合类型安全性的操作符。
malloc返回的是void*指针，需要通过强制类型转换将void\*指针转换成需要的类型。存在类型安全隐患。
4. new分配失败会抛出异常。malloc分配失败会返回NULL
5. new会首先调用operator new函数，申请足够的内存(通常底层使用malloc实现)。然后调用类型的构造函数，初始化成
员变量，最后返回类型的指针。delete先调用析构函数，然后调用operator delete函数释放内存(通常底层用free实现)。
malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。

### delete p delete []p allocator 作用
1. 动态数组管理new一个数组时，[]中必须是一个整数，但是不一定是常量整数。普通数组中必须是一个常量整数。
2. new 动态数组返回的并不是数组类型，而是一个元素类型的指针。
3. delete[]时，数组中的元素按逆序的顺序进行销毁
4. new 在内存分配上有一些局限性，new的机制时将内存分配的对象和对象构造组合在一起，同样的，delete也是将对象析构
和内存释放组合在一起。allocator将这两部分分开进行，先申请一部分内存，不进行初始化对象，只有当需要的时候才进行
初始化对象。

### new和delete的实现原理，delete时如何知道释放内存的大小的?
1. new简单类型直接调用operator new分配内存；
而对于复杂结构，先调用operator new分配内存，然后在分配的内存上调用构造函数。
对于简单类型，new []计算好大小后调用operator new；
对于复杂结构，new[]先调用operator new[]分配内存，然后再p的前四个字节写入数组大小n，然后调用n次构造函数。针对
复杂类型，new[]会额外存储数组大小
2. delete简单数据类型默认只是调用free函数；复杂数据类型先调用析构函数再调用operator delete;针对简单类型,
delete和delete[\]等同。假设指针p指向new\[]分配的内存，因为要用4字节存储数组大小，实际分配的内存地址为[p-4],
系统记录的也是这个地址。delete[]释放的就是p-4指向的内存。而delete会直接释放p指向的内存，这个内存根本没有被
系统记录，所以会崩溃。

### malloc申请的存储空间能用delete释放吗
不能，malloc/free主要为了兼容C，new和delete完全可以取代malloc/free的。
malloc/free的操作对象都是必须明确大小的，而且不能用在动态类上。
new和delete会自动进行类型检查和大小，malloc和free不能执行构造函数与析构函数，所以动态对象它时不行的。
当然从理论上说使用malloc申请的内存是可以通过delete释放的，不过一般不这样写，不能保证每个C++的运行时都
能正常。


### malloc与free的实现原理
1. 在标准C库中，提供了malloc/free函数分配释放内存，这两个函数底层是由brk、mmap、munmap这些系统调用实现的。
2. brk是将数据段(.data)的最高地址指针_edata往高地址推，mmap是在进程的虚拟地址空间中(堆和栈中间，成为文件
映射区的地方)找一块空闲的虚拟内存。这两种方式分配的都是虚拟内存，没有分配物理内存。
3. malloc小于128k的内存，使用brk分配内存，将_edata往高地址推；malloc大于128k的内存，使用mmap分配，使用
mmap分配内存，在堆和栈之间找一块空闲内存。brk分配的内存需要等到高地址内存释放以后才能释放，mmap分配的内存
可以单独释放。