### 全局变量和局部变量的区别
1. 生命周期不同。全局变量随主程序创建而创建，随主程序退出而销毁。生命周期与进程相同。局部变量的生命周期就在{}作用域内。
2. 作用范围不同。全局变量只要声明了就可以访问(extern)。局部变量出了作用域后就无法访问。
3. 存储位置不同。全局变量存储在数据区，也就是.data段。局部变量存储在栈空间上。

### 函数调用的原理
1. 器用栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复以及本地存储。寄存器中有两个指针: esp栈顶指针和ebp栈底指针。这两个指针的中间区域就是该函数的栈帧。
2. 当A调用B时，首先准备B的参数，压入栈中。call命令压入返回地址后，执行权到B函数中。B函数先将ebp压入栈中，即保存A函数的栈底，然后将esp赋值给ebp，此时ebp寄存器就保存着B函数的栈底。然后获取参数进行计算。返回时恢复A函数的ebp。

### C++中指针传递和引用传递的区别
1. 指针传递本质上还是值传递，它传递的是一个地址值。值传递的过程中，被调函数的形参作为被调函数的局部变量处理，会在栈中开辟空间存放主函数传递进来的实参值，从而形成了一个实参的副本。
值传递的特点是，被调函数对形式参数的任何操作都是按局部变量处理的，所以不会影响到调用者中传递的参数。
2. 引用参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是主调函数放进来的实参的地址。被调函数对形参的任何操作都被处理程间接寻址，即通过栈中存放的地址访问主调函数中的实参变量。因此，此时任何修改都会反应到实参上。
3. 引用传递和指针传递是不同的，虽然它们都是在被调函数栈空间上开辟的一个局部变量，但是对于任何引用参数的处理都会通过一个间接寻址的方式操作到主调函数中的相关变量。
而对于指针传递的参数，如果改变被调函数中的指针地址，它将作用不到主调函数中实参。
4. 从编译的角度来讲，程序在编译时分别将指针和引用添加到符号表上，符号表中记录的是变量名以及变量所对应地址。指针变量在符号表上对应的地址值为其本身的地址值，而引用在符号表上对应的地址值为引用对象的地址值(与实参名字不同，地址相同)。符号表生成之后就不会再改，因此指针可以改变其指向的对象(指针变量中的值可以改变)，而引用对象则不能再修改。