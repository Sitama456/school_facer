### 进程是什么
进程是指一个具有一定**独立功能**的程序在一个**数据集合上**的**一次动态执行过程**。

### 操作系统如何描述一个进程
1. 操作系统使用进程控制块描述进程实体。进程控制块中维护了进程动态执行期间的一切信息。是操作系统管理进程的核心数据结构，是系统中存在某个进程的标志。
2. 进程创建首先创建的是进程控制块，进程撤销最后撤销的是进程控制块。
3. 进程控制块中包含了进程的基本信息，比如进程状态，进程PID，内核栈指针，需要被调度的标志，保存进程上下文，进程页目录物理地址，进程线性地址结构体，子进程父进程指针等等。系统把所有进程组织成一个大链表，每个进程控制块还可能因为不同的原因处于其他各自的链表之中，如阻塞原因构成的阻塞队列、等待队列、就行队列等。

### 进程状态有几种？怎么切换的
1. 系统中的进程状态有未初始化态，阻塞态，就绪态。运行态和僵尸态。
2. 进程控制块刚被创建时就是未初始化状态，当初始化完成之后(fork结束阶段)就会将进程的状态设置未就绪态。
3. 当进程得到CPU执行权时，就会变成运行态。
4. 在运行过程中，由于等待某个事件发生或者主动调用sleep函数，进程状态变为阻塞态。
5. 进程运行结束退出，变成僵尸态，等待父进程回收资源。

### 进程中比较重要的资源是什么？
1. 内核栈。系统中会有不同的内核线程、不同的用户进程，每个线程或者进程都有自己独立的内核栈。
2. 进程内存描述符与线性区。每个进程都有一个内存描述符和数个线性区。内存描述符指针在进程控制块中记录，而线性地址区则由内存描述符来记录，里面保存了进程的合法访问的线性地址空间。
3. 进程页目录表。每个进程都有自己单独的页目录表和页表。当然，和其他进程共享地址空间除外。进程创建时需要创建进程的页目录和页表。页目录的内核地址空间部分与内核页目录的表项相同，而其用户地址空间部分则是在进程创建时通过fork或者execeve过程建立。

### 系统如何创建内核线程
1. 内核中的执行流一般以内核线程的形式存在，而用户程序存在的单位是用户进程。可以认为，所有内核线程都是内核这个大进程中的线程，它们共享内核的地址空间和全局数据，可以无障碍地访问内核所有功能。
2. 内核创建的第一个线程是idle线程，称为0号线程。在idle线程中又创建了init线程，称为为1号线程。1号线程是系统中所有进程的祖宗。
3. 创建idle线程时，只需要分配一个新的进程控制块(线程控制块)，并设置好内核栈就，设置页内核页目录就可以了。创建的方式十分简单，因为它是当前内核执行流"进程化"的结果，因此不需要加载新的程序代码。作为内核线程，它访问内存的方式与用户进程不同，没有内存描述符，也没有线性区链表。唯一要做的，就是拥有一个进程控制块，并设置其中必要的数据，比如PID、进程状态、记录内核栈、调度标志等。
4. 在idle线程创建完毕后，内核立即着手创建init线程。由于init线程不是在当前执行流的基础上创建的，所以创建过程会有所不同。
   1. 创建内核线程的函数是kernel_thread()。参数中必须传入一个函数指针作为该内核线程的执行流。在kernel_thread()中，要先分配一个临时中断帧，简单地伪造一个内核程序被中断的假象。并且修改中断帧中的返回地址为特定的函数kernel_thread_entry。
   2. 之后调用do_fork()函数。创建进程或线程时，do_fork()采用的是一分为二的创建方式，即新进程创建完毕后，会出现两个完全一样的执行流。所以do_fork()函数需要将父进程的中断帧传递进来。
   3. do_fork()函数调用返回后，init线程就被成功创建了。当init线程被调度时，会层层中断返回到其中断帧记录的返回地址中，即kernel_thread_entry函数。该函数将参数压入init的内核栈中，然后调用创建init线程传入的函数指针fn，就切换到了init线程执行流中。


### 如何创建用户进程
1. 进程都是由父进程调用fork()系统调用创建的。fork()返回后，系统的进程控制块链表会多一个与父进程基本一样的进程控制块，并将其放在就绪队列中。
2. 父进程调用fork()系统调用后，触发中断，执行流转到中断处理服务程序，根据中断号进入系统调用总函数，再根据系统调用号，进入do_fork()进程复制函数。该函数的参数是父进程的中断帧tf,栈顶指针stack和标志位。
3. do_fork()返回值是子进程的PID号，然后父亲进程经过中断返回执行流层层返回到用户态调用forK()函数的下一句。
4. 当子进程被调度时，由于拷贝了父进程的中断帧，在返回时也会返回到调用fork()的下一句。与父进程不同的是，子进程并没有实际触发过中断，所以它不会从系统调用do_fork()返回到syscall()在返回到alltraps()中。所以必须在do_fork()中修改子进程PCB的相关内容，使其被调用时可以正确返回。返回值是0。


### 详细说说do_fork()函数
1. do_fork()函数是一个具体的系统调用，它的系统调用号就是用户态调用fork()函数中展开的调用号。
2. 经过中断分发、系统调用分发进入到do_fork()中后，此时的参数是父进程的中断帧、用户态栈顶指针和标志。
3. 首先系统会向申请一个进程控制块，并让其父进程指针指向当前进程。如果申请失败，返回内存不足的错误码。
4. 申请两个页面作为子进程的内核栈。
5. 拷贝父进程的打开文件列表。。。
6. 拷贝父亲进程的内存描述符。
   - 如果父进程的内存描述符mm为空，说明父进程是内核线程，则不创建子进程的mm。
   - 如果拷贝标志设置为共享父进程的mm，则直接将子进程mm指针指向父进程的mm。
   - 如果是真的拷贝。则先申请一个页面作为子进程的顶级也目录，并把内核部分的页目录拷贝进来，即所有进程的内核部分映射都是一样的。然后拷贝父进程的线性区。遍历mm中的所有线性区vma，创建通用的vma,并且申请物理页，将父进程完成映射的线性区映射的物理页数据都拷贝到新的物理页中，并且设置好页表映射。
7. 拷贝父进程的中断帧。在内核栈中分配一个中断帧的内存空间，将父进程的中断帧拷贝到子进程中内核栈的中断帧。这样中断返回时，父子进程都将从fork()下一条指令开始运行。设置子进程中断帧的eax成员值为0，该值最终作为fork()的返回值。设置子进程的栈顶指针与父进程相同。最后修改子进程PCB中的进程上下文，使得子进程在得到调度后正确返回到用户空间。

### init 线程做了什么
1. 内核创建完idle线程和init线程后，在init线程的执行流中又创建了系统的第一个用户进程的前身，user_main()线程。所以说，init线程时系统所有用户进程之祖，而init线程在进程树中的父进程是idle线程。
2. init线程创立后，将成为系统中一切工作的外壳。它先记录系统的内存使用状态，然后创建第一个用户进程sh。所有用户进程执行完毕后(包括sh进程)， 它才会走向关闭系统。系统关闭前，它会卸载文件系统，对内存做简单检查。

### 加载用户进程
1. 内核创建idle线程和init线程后，init线程中进一步创建user_main内核线程。该线程是用户进程的前身，它最终将演变程用户进程sh。sh是系统启动后运行的终端，运行在用户态。此后，系统所有的用户进程都由sh派生。
2. user_main内核线程被创建好之后，将在其执行中调用kernel_execve()函数。该函数的参数是进程名字，和路径。然后展开成一个系统调用。此时user_main执行流本身就处于内核态，为什么要通过系统调用去调用进程加载程序呢？这时因为user_main最终是要返回到用户态的，有进才有出，所以先用中断的形式加载进程代码后，再修改中断帧中的相关成员。
3. 执行流转到do_execve()函数，该函数的功能是在已有进程中加载新的代码、数据。
   - 检查参数是否合法，比如参数个数、参数类型。由于do_execve()在用户态中最常用，命令行参数最多数用在用户空间，所以将参数拷贝值内核栈中。
   - 获取当前进程内存描述符mm,关闭打开的文件列表。同时打开传入的文件(即可执行文件名)。
   - 如果mm不为空，即当前进程是用户态的进程，则先装在内核的顶级页目录。判断此时内存描述符的引用计数是否为0，为0则撤销当前进程的虚实映射关系，释放当前进程页目录，回收内存描述符。
   - 调用load_icode()将硬盘上的文件加载到内存中。
4. 执行流转到load_icode函数。
   - 申请一个内存描述符mm，并初始化。
   - 申请内核栈空间，申请一个页作为顶级页目录，并设置好内核空间的映射关系。
   - 通过传入的fd描述符读取ELF格式的文件。
      - 首先读取ELF头，检验魔数。声明段头结构体、段头结构体指针，遍历ELF中的各个段。如果文件中段大小大于内存中的段大小，则不合法。
      - 然后解析段头信息，判断线性区是否可执行、可读写、只读等。然后待用mm_map()函数建立新线性区的映射，并插入到线性区链表中。
      - 读取段的起始虚地址，其向下4K对齐。循环读取文件的段内容。每次分配一个物理页，并建立虚拟地址到物理地址的映射关系。从文件偏移位置中读入一个page的大小，直到这个段被加载到内存中。
      - 循环所有段，整个程序都被加载到内存中。
   - 可执行文件的所有段都被加载到内存中后，为用户栈预先分配4个物理页并且建立好虚实映射关系。之后将PCB的mm指针指向刚才创建的mm结构体对象，加载进程的顶级页目录。
   - 将命令行参数拷贝值用户栈的栈底位置。
   - 为进程返回到用户态的指定入口做准备，即修改中断帧。获取由user_main线程执行软中断时产生的中断帧，全部成员都设为0。然后修改中断帧中的代码段、数据段、栈顶指针为用户态的。设置eip为elf头中的入口地址。就正常返回。
5. 经过系统调用返回、中断返回之后，执行流并不会返回到user_main线程执行流中调用kernel_execve()的下一句，因为在load_icode函数中已经修改了中断帧的返回值，所以最终user_main会返回到加载的程序的入口地址，变成一个用户进程sh。