### 什么是进程调度
1. 进程调度的问题是如何选择下一个运行的进程的问题。换句话说，从就绪队列中选择那个进程执行就是进程调度需要考虑的问题。

### 进程调度有哪些算法？
1. 先来先服务算法。非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于段作业。因为短作业可能要一直等到长作业执行完，等待时间过长。
2. 短作业优先。非抢占式调度算法，按估计运行时间最短的顺序进行调度。长作业可能会被饿死。
3. 最高响应比优先算法。非抢占式算法。综合考虑了等待时间和运行时间。执行时间越短，等待时间越长，响应比就越大。算法每次总是选具有最大相应比的进程。
4. 最短剩余时间优先。最短作业的抢占式版本。按剩余运行时间顺序进行调度。当一个新的作业到达时，其整个运行时间和当前进程的剩余时间作比较，如果新进程更小，则挂起当前进程，运行新的进程。
5. 时间片轮转。将所有进程按到达顺序排成一个队列，每次调度时，把CPU时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计数器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾。算法效率与时间片的大小有很大关系。时间片太小，切换就过于频繁。时间片太长，实时性就不能得到保证。
6. 多级队列算法。把就绪队列划分成多个独立的子队列的思想，每个队列的调度策略可能不同，队列间的调度可采用优先级或RR。
7. 多级反馈队列算法。是多级队列算法的改进。相比于前者，这时一种进程可在不同队列间移动的多级队列算法。通常，每个队列中进程所拥有的时间片大小不同。高优先级队列进程时间片短，低优先级进程时间片长。新进入的进程都会放入最高优先级，如果时间片用完仍没有执行完毕，则会被移人低一级的优先队列中去，以此类推直至进入最后一个队列。所以，CPU密集型进程优先级会很快下降，到低优先级长时间片中去，而短进程、IO密集型进程则更容易留在高优先级。随着进程的执行，如果某个时刻多数进程都指向在中低优先级队列中，突然来到一个新进程，此时新进程在最高优先级队列中，它能够立刻获得处理机使用权。是基于抢占式调度算法。


### 抢占式与非抢占式调度算法的区别
1. 抢占式算法指按照某个指标，比如优先级判断是否抢占正在运行的进程。即当前运行的进程一定式指标最好的。抢占式算法饿调度次数会更频繁，而每调度一次都会引起保护线程、恢复现场，所以开销更大。
2. 非抢占式算法：当前进程执行完才会发生调度。不利于长作业和实时性。

### 具体如何如何实现调度
1. 进程调度功能进程调度框架下和调度器共同配合完成的。其中，进程调度框架提供了发生调度的时机，而调度器则是以某种算法选出下一个要运行的进程。
2. 项目中对进程的调度离不开时钟中断。系统管理一个定时器链表，每当时钟中断发生时，中断分发函数将会执行时钟中断的处理函数，首先遍历定时器链表中的定时器，给每个定时器的过期时间成员减1。如果遇到过期的定时器(即过期时间为0)，则调用唤醒函数把定时器所属的进程加入到就绪队列中，并删除该定时器。
3. 在时钟中断处理函数中还会检查当前进程的剩余时间片，将其减1。如果减到0，就会把当前进程调度标志置1，在中断返回时，检查到该标志，将执行进程调度。
4. 进程调度的核心函数是schedule()，它首先复位当前进程的调度标志，如果当前进程是运行态，则将其设置为就绪态，然后插入到就绪队列中。用调度器选择下一个要运行的进程，并从就绪队列中删除它。如果没有选择进程，则调度idle进程。如果选择的进程不是当前进程，则执行进程切换，完成调度。
5. 除了在时钟中断中调度进程之外，还有其他的调度点，比如do_sleep()系统调用，加锁失败系统调用，等待子进程系统调用等，这些是进程主动放弃CPU。

### 时间片轮转调度器的实现
进程调度器，实际上是一组函数功能和数据结构。进程调度器的函数指针都会保存在一个调度器结构体中。系统使用该调度器，只需要把相应的函数指针指向某具体算法的调度函数即可。项目中指向的是时间片轮转调度算法的函数。
1. 时间片轮转算法仅需要一个运行队列，运行队列的最大时间片在初始化函数中设置。
2. 入队操作，如果进程时间片用完或者不合法，直接修改为队列的时间片，否则就保持原来省些的时间片。将此进程插入运行队列队尾。
3. 出队操作，把进程从队列中删除，并修改队列进程数即可。
4. 进程选取操作。如果队列非空，只需要选取第一个进程即可。
5. 时钟事件处理。把当前进程时间片减1。减到0就设置调度标志。

### 守护进程是什么？怎样创建
守护进程是指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的。创建方法是：
1. 调用fork(),产生一个子进程，然乎使父进程退出。
2. 调用setsid()创建一个新对话期。控制终端、登录会话和进程组通常是从父进程继承下来的，守护进程要摆脱它们，不受它们的影响。调用setsid()使进程成为一个绘画组长。调用成功后，进程成为新的会话组长和进程组长，并与原来的登录会话、进程组和控制终端脱离。
3. 禁止进程重新打开控制终端。方法是再一次通过fork()创建新的子进程，并使调用fork的进程退出。
4. 关闭不再需要的文件描述符。如不关闭，将会浪费系统资源，造成进程所在的文件系统无法卸下以及引起无法预料的结果。
5. 将当前目录更改为根目录。
6. 子进程将屏蔽字清零。
7. 处理SIGCHILD信号。

### 什么是孤儿进程
如果父进程先退出，子进程还没有退出，那么子进程的父进程将变为init进程。
一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。孤儿进程将被init进程收养。

### 什么是僵尸进程
如果子进程退出，父进程还没有退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个子进程就成为僵尸进程。
设置僵尸进程的目的是维护子进程的信息，以便父进程在以后某个时候获取。这些信息至少包括进程ID,进程的终止状态等。所以当子进程终止，父进程调用wait或waitpid就可以得到这些信息。
